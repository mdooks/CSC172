Nicholas Graham
ngraham@u.rochester.edu
CSC 172
Project 3
Lab TA: Kate Zeng Zhiming
Lab Session: Wednesday 6:15 - 7:30

For this project I had to build a program to make a tree out of lines given that crossed the unit square. Then I had to be able to tell if two given points were separated by any of the lines in the graph. I started by setting up classes for the points and the lines. Once that was done, I set up the structure for the binary search tree based off of the previous lab. Then I looked into how to build the tree. A method was given to test whether or not a point was Clockwise or counter clockwise from two other points. Using that and a method I wrote to test if two lines intersected, I built the tree. If the lines intersected the new line was inserted on both sides, other wise it was only inserted on one based off of whether the points were clockwise or counter clockwise to the given line. Testing whether the points were in the same region or not was very similar. I built a line out of the two points being tested, and if that "line" intersected any in the tree then they were not in the same space. I was able to have that "line" go through the tree just like it was being inserted so the run time could be kept to long(n). Unfortunately another helper method had to be written to continue to divide the line down to its smallest segment in order to meet the specifications in the clarifications of the project. This adds to the runtime of the point checking. To look at the splitting of the line, I passed the node that the 2 points intersected with into the method, as well as the line that the points made. I then tested to see if the line segments created by the intersections of its children and the end points of the line to see which one intersected the line made by the test points. I then updated the line to be printed out, and went down into the tree more, until a null node was found. The only other way to exit this loop is when a line is intersected but the math does not end up working do to the small rounding errors throughout the process of testing. (example being 0.3 becoming 0.3000002). Once that was done I then began writing the method to count the external path lengths and the number of external nodes. I then set it up to print out the average path length based off of these values. I then set up 11 test cases. These can all be found in the graphs sub folder, where the sample outputs are also stored. The tests are numbered 1 through 11 in the format Graph1.txt

Test cases 1 and 2 look at a simple one line graph, proving that the very basics of the program work. Test cases 3 and 4 look at instances where there are two lines, but they do not intersect, again just showing that the basics work. Test case 5 looks at the first 2 line graph with an intersection. Case 6 looks at horizontal and vertical lines intersecting, which did take extra consideration when programing. Then cases 7 and 8 look at parallel lines that are horizontal or vertical. Case 9 adds in a third line, and test cases 10 and 11 add in a fourth. Case 12, shows lines that share a start or end point.

Overall I can say that this is not the best work I could have done, nor is probably the best way to approach solving the problem. If I were to redo this I would try to handle some of the degenerate cases I found in a more graceful way then I did.

The degenerate cases I ended up handling were vertical lines, as well as lines that have the same starting or ending point being given in the initial graph. I looked into handling points that fell on a given line, as well as three lines intersecting in one point, but did not have time to handle those.

The Average path length, based off of the data I collected increased each time a line with no intersections was increased and decreased if it intersected another line. This is because while the new line still increased the path length, if it intersected it would get inserted twice, thus increasing the number of external nodes. Naturally the more intersections the more it would decrease.

To compile run: javac *.java
to run: java test graphs/Graph11.txt

*replace the 11 with numbers 1 -  12 to view all the test cases I have prepared.
